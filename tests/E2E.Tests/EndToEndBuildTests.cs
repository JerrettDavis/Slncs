using System.Diagnostics;
using Xunit.Abstractions;

namespace E2E.Tests;

public class EndToEndBuildTests(ITestOutputHelper output)
{
    private static string RepoRoot()
    {
        var bin = AppContext.BaseDirectory;
        return Path.GetFullPath(Path.Combine(bin, "..", "..", "..", "..", ".."));
    }

    [Fact]
    public void Dotnet_Build_Works_On_Slncs_Wrapper()
    {
        var root = RepoRoot();
        var samplesBaseDir = Path.Combine(root, "samples");
        var samplesDir = Path.Combine(samplesBaseDir, "template");
        var wrapper = Path.Combine(samplesDir, "MyCsSln.slncs");
        Assert.True(File.Exists(wrapper), "Sample wrapper must exist.");

        var psi = new ProcessStartInfo("dotnet", $"build \"{wrapper}\" -c Debug -v:m --nologo")
        {
            RedirectStandardError = true,
            RedirectStandardOutput = true,
            UseShellExecute = false,
            WorkingDirectory = samplesDir
        };
        var p = Process.Start(psi)!;
        p.WaitForExit();
        var stdout = p.StandardOutput.ReadToEnd();
        var stderr = p.StandardError.ReadToEnd();
        if (p.ExitCode != 0)
        {
            output.WriteLine("--- wrapper stdout ---\n" + stdout);
            output.WriteLine("--- wrapper stderr ---\n" + stderr);
        }

        Assert.Equal(0, p.ExitCode);
        output.WriteLine(stdout);

        var slnx = Path.Combine(samplesDir, "obj", "MyCsSln.slnx");
        Assert.True(File.Exists(slnx), ".slnx should be generated by wrapper.");

        var consoleDll = Path.Combine(samplesDir, "src", "ConsoleApp1", "bin", "Debug", "net8.0", "ConsoleApp1.dll");
        if (!File.Exists(consoleDll))
        {
            output.WriteLine("ConsoleApp1.dll missing; dumping directory tree under samples/src:");
            foreach (var path in Directory.EnumerateFiles(Path.Combine(samplesDir, "src"), "*", SearchOption.AllDirectories))
                output.WriteLine(path);
        }

        Assert.True(File.Exists(consoleDll), "Console application should have been built by direct parse pipeline.");
    }

    [Fact]
    public void Slncs_Build_Tool_Works_On_Pure_Script()
    {
        var root = RepoRoot();
        var samplesBaseDir = Path.Combine(root, "samples");
        var samplesDir = Path.Combine(samplesBaseDir, "template");
        var toolDir = Path.Combine(root, "src", "Slncs.Tool");
        Assert.True(Directory.Exists(toolDir), "Tool project must exist");

        var pureScript = Path.Combine(samplesDir, "MyCsSlnSingle.slncs");
        File.WriteAllText(pureScript,
            "using Slncs;\nSolution.Create()\n    .Folder(\"/Solution Items\", f => f.Files(\"Directory.Build.props\"))\n    .Project(@\"src/ClassLibrary1/ClassLibrary1.csproj\")\n    .Project(@\"src/ConsoleApp1/ConsoleApp1.csproj\")\n    .Write(OutputPath);\n");

        var psi = new ProcessStartInfo("dotnet", $"run --project \"{toolDir}\" -- \"{pureScript}\"")
        {
            RedirectStandardError = true,
            RedirectStandardOutput = true,
            UseShellExecute = false,
            WorkingDirectory = samplesDir
        };
        var p = Process.Start(psi)!;
        p.WaitForExit();
        var stdout = p.StandardOutput.ReadToEnd();
        var stderr = p.StandardError.ReadToEnd();
        if (p.ExitCode != 0)
        {
            output.WriteLine("--- tool stdout ---\n" + stdout);
            output.WriteLine("--- tool stderr ---\n" + stderr);
        }

        Assert.Equal(0, p.ExitCode);
        output.WriteLine(stdout);

        var slnx = Path.Combine(samplesDir, "obj", "MyCsSlnSingle.slnx");
        Assert.True(File.Exists(slnx), ".slnx should be generated for pure script.");

        var consoleDll = Path.Combine(samplesDir, "src", "ConsoleApp1", "bin", "Debug", "net8.0", "ConsoleApp1.dll");
        Assert.True(File.Exists(consoleDll), "Console application should have been built by slncs-build tool.");

        // cleanup generated script to keep repo clean for subsequent tests
        try
        {
            File.Delete(pureScript);
        }
        catch
        {
            /* ignore */
        }
    }
}